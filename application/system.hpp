#include "autogenerated/embed_models.hpp"
#include "../libs/system_base.hpp"
#include "../libs/solver/solver_dp5.hpp"
// #include "../libs/solver/solver_ck54.hpp"
// #include "../libs/solver/solver_f78.hpp"

class CSystem: public CSystem_Base
{
protected:
	time_type last_observed_time;
	intermediate_type last_observed_intermediates;

public:

	time_type next_sudden_change_time;

	const value_type eps_rel=1E-10;
	const value_type eps_abs=1E-10;
	const time_type max_dt=0.0;
	const time_type min_dt=1E-6;

	CSystem(): CSystem_Base()
	{
		// constructor
	}

	void observer(const state_type &x, const double &t,const double &next_dt)
	{
		input_type u;
		next_sudden_change_time=Model::input(t,u);
		observer_type ymat;
		Model::observer(x,t,ymat,last_observed_intermediates,last_observed_time,u);
		results_push(t,next_dt,ymat);
		intermediate_type new_mids;
		Model::intermediates(u,x,new_mids,t,last_observed_intermediates,last_observed_time);
		last_observed_time=t;
		last_observed_intermediates=new_mids;
	}

	void rhs(const state_type &x, state_type &dxdt, const double t)
	{
		input_type u;
		next_sudden_change_time=Model::input(t,u);
		Model::rhs(x,dxdt,t,last_observed_intermediates,last_observed_time,u);
	}

	double timer(const state_type &x, const double t)
	{
		_unused(x);
		return t+10000;
	}

	size_t integrate_adaptive(
			state_type &start_state,
			const time_type start_time,
			const time_type end_time,
			const time_type dt_init)
	{
		ode::Solver<ode::Steppers::RKDP5,CSystem> solver(std::ref(*this));
		last_observed_time=start_time;
		last_observed_intermediates.zeros();
		next_sudden_change_time=end_time;
		size_t return_val=
			solver.integrate_adaptive(
				start_state,// is manipulated
				start_time ,
				end_time ,
				dt_init);
		results_finalize();
		post_solve();
		// std::cout<<"Results("<<files::now_print<<") SHA1: ";
		// std::cout<<sha1sum(results).signature()<<std::endl;
		return return_val;
	}

};
